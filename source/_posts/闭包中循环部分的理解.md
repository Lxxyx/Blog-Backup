title: 闭包中循环部分的理解
date: 2016-01-08 09:23:39
tags: 前端
---
```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
```
这是一段很经典的代码。之前一直无法理解，为什么` console.log(i)`的时候，i是10而不是a[i]所对应的值。

看似数组`a`中，每个元素都取到了相应的i。

但是。数组`a`其实取到的是那个函数，`i`的话，其实是在运行的时候读取的。

如果运行`a[6]();`函数，那么实质上`i`从全局作用域中读取，此时的`i`已经是循环结束后的那个10了。

对此，只需稍作改造。
```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = (function(num) {
    return function() {
      console.log(num)
    }
  })(i)
}
a[6]();
```
我们把
```
  a[i] = function () {
    console.log(i);
  };
```
改成了
```
  a[i] = (function(num) {
    return function() {
      console.log(num)
    }
  })(i)
```
此时，循环中的`i`作为`num`的值传递给匿名立即执行函数，函数运行后返回一个函数，保持着对传进来的`num`的引用。十个函数便有十个闭包。

此时`a[i]`又等于函数。运行`a[i]`时，就会读取闭包所保存的变量。

到这儿的话，总算对闭包有所了解了。

包括之前迷迷糊糊的this值指来指去，闭包会导致内存泄漏等问题。总算是了解了个清楚。下回写博客时候，给一起写出来。

> [let的基本用法，也是总算对闭包有所了解的地方](http://es6.ruanyifeng.com/#docs/let#基本用法)